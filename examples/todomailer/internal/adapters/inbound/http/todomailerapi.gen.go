//go:build go1.22

// Package http provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package http

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for EmailStatus.
const (
	FAILED  EmailStatus = "FAILED"
	PENDING EmailStatus = "PENDING"
	SENT    EmailStatus = "SENT"
)

// Defines values for ErrorResponseErrorCode.
const (
	BADREQUEST    ErrorResponseErrorCode = "BAD_REQUEST"
	INTERNALERROR ErrorResponseErrorCode = "INTERNAL_ERROR"
	NOTFOUND      ErrorResponseErrorCode = "NOT_FOUND"
)

// Defines values for TodoStatus.
const (
	DONE TodoStatus = "DONE"
	OPEN TodoStatus = "OPEN"
)

// CreateTodoRequest Request payload for creating a todo.
type CreateTodoRequest struct {
	// DueDate Calendar due date (date only, no time component).
	DueDate openapi_types.Date `json:"due_date"`

	// Title Human-readable todo title. Must be non-empty.
	Title string `json:"title"`
}

// EmailStatus Completion email delivery status. PENDING: todo is DONE and email needs to be sent (or retried). FAILED: last attempt failed; the worker will retry. SENT: email delivered successfully. Note: For OPEN todos, email_status is typically SENT to mean "no pending email work".
type EmailStatus string

// ErrorResponse Standard error envelope.
type ErrorResponse struct {
	// Error Error details.
	Error struct {
		// Code Machine-readable error code.
		Code ErrorResponseErrorCode `json:"code"`

		// Message Human-readable error message.
		Message string `json:"message"`
	} `json:"error"`
}

// ErrorResponseErrorCode Machine-readable error code.
type ErrorResponseErrorCode string

// ListTodosResponse A paginated list of todos.
type ListTodosResponse struct {
	// Items List of todos, including completion email delivery status fields.
	Items []Todo `json:"items"`

	// NextPage Opaque cursor to fetch the next page of results. Null if there are no more pages.
	NextPage *int `json:"next_page"`

	// Page Opaque cursor to fetch the current page of results. Omit or set to null when fetching the first page.
	Page int `json:"page"`

	// PreviousPage Opaque cursor to fetch the previous page of results. Null if there is no previous page.
	PreviousPage *int `json:"previous_page"`
}

// Todo A todo item with completion-email delivery status. Email is sent asynchronously only when status is DONE.
type Todo struct {
	// CreatedAt Timestamp when the todo was created.
	CreatedAt time.Time `json:"created_at"`

	// DueDate Calendar due date (date only, no time component).
	DueDate openapi_types.Date `json:"due_date"`

	// EmailAttempts Number of attempts made by the background worker to send the completion email. Resets to 0 when transitioning from OPEN -> DONE.
	EmailAttempts int `json:"email_attempts"`

	// EmailLastError Last error message from the email provider call, if the most recent attempt failed. Null when email_status is SENT or when no attempts have failed.
	EmailLastError *string `json:"email_last_error"`

	// EmailProviderId Provider-specific message identifier returned upon successful send (if available). Null until a successful delivery occurs.
	EmailProviderId *string `json:"email_provider_id"`

	// EmailStatus Completion email delivery status. PENDING: todo is DONE and email needs to be sent (or retried). FAILED: last attempt failed; the worker will retry. SENT: email delivered successfully. Note: For OPEN todos, email_status is typically SENT to mean "no pending email work".
	EmailStatus EmailStatus `json:"email_status"`

	// Id Unique identifier for the todo.
	Id openapi_types.UUID `json:"id"`

	// Status Todo lifecycle status. OPEN means the todo is active. DONE means the todo has been completed (triggers async email enqueue on transition).
	Status TodoStatus `json:"status"`

	// Title Human-readable todo title.
	Title string `json:"title"`

	// UpdatedAt Timestamp when the todo was last updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// TodoStatus Todo lifecycle status. OPEN means the todo is active. DONE means the todo has been completed (triggers async email enqueue on transition).
type TodoStatus string

// UpdateTodoRequest Partial update payload. Provide at least one of: title, status, due_date. Setting status to DONE triggers async completion email enqueue if transitioning from OPEN -> DONE.
type UpdateTodoRequest struct {
	// DueDate Updated calendar due date (date only).
	DueDate *openapi_types.Date `json:"due_date,omitempty"`

	// Status Todo lifecycle status. OPEN means the todo is active. DONE means the todo has been completed (triggers async email enqueue on transition).
	Status *TodoStatus `json:"status,omitempty"`

	// Title New title for the todo. Must be non-empty if provided.
	Title *string `json:"title,omitempty"`
	union json.RawMessage
}

// UpdateTodoRequest0 defines model for .
type UpdateTodoRequest0 = interface{}

// UpdateTodoRequest1 defines model for .
type UpdateTodoRequest1 = interface{}

// UpdateTodoRequest2 defines model for .
type UpdateTodoRequest2 = interface{}

// BadRequest Standard error envelope.
type BadRequest = ErrorResponse

// NotFound Standard error envelope.
type NotFound = ErrorResponse

// ListTodosParams defines parameters for ListTodos.
type ListTodosParams struct {
	// Status Filter todos by status.
	Status *TodoStatus `form:"status,omitempty" json:"status,omitempty"`

	// Pagesize Maximum number of todos to return (server may cap).
	Pagesize int `form:"pagesize" json:"pagesize"`

	// Page Opaque cursor from a prior ListTodosResponse to fetch the next page. Omit or set to null to fetch the first page.
	Page int `form:"page" json:"page"`
}

// CreateTodoJSONRequestBody defines body for CreateTodo for application/json ContentType.
type CreateTodoJSONRequestBody = CreateTodoRequest

// UpdateTodoJSONRequestBody defines body for UpdateTodo for application/json ContentType.
type UpdateTodoJSONRequestBody = UpdateTodoRequest

// AsUpdateTodoRequest0 returns the union data inside the UpdateTodoRequest as a UpdateTodoRequest0
func (t UpdateTodoRequest) AsUpdateTodoRequest0() (UpdateTodoRequest0, error) {
	var body UpdateTodoRequest0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateTodoRequest0 overwrites any union data inside the UpdateTodoRequest as the provided UpdateTodoRequest0
func (t *UpdateTodoRequest) FromUpdateTodoRequest0(v UpdateTodoRequest0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateTodoRequest0 performs a merge with any union data inside the UpdateTodoRequest, using the provided UpdateTodoRequest0
func (t *UpdateTodoRequest) MergeUpdateTodoRequest0(v UpdateTodoRequest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateTodoRequest1 returns the union data inside the UpdateTodoRequest as a UpdateTodoRequest1
func (t UpdateTodoRequest) AsUpdateTodoRequest1() (UpdateTodoRequest1, error) {
	var body UpdateTodoRequest1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateTodoRequest1 overwrites any union data inside the UpdateTodoRequest as the provided UpdateTodoRequest1
func (t *UpdateTodoRequest) FromUpdateTodoRequest1(v UpdateTodoRequest1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateTodoRequest1 performs a merge with any union data inside the UpdateTodoRequest, using the provided UpdateTodoRequest1
func (t *UpdateTodoRequest) MergeUpdateTodoRequest1(v UpdateTodoRequest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateTodoRequest2 returns the union data inside the UpdateTodoRequest as a UpdateTodoRequest2
func (t UpdateTodoRequest) AsUpdateTodoRequest2() (UpdateTodoRequest2, error) {
	var body UpdateTodoRequest2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateTodoRequest2 overwrites any union data inside the UpdateTodoRequest as the provided UpdateTodoRequest2
func (t *UpdateTodoRequest) FromUpdateTodoRequest2(v UpdateTodoRequest2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateTodoRequest2 performs a merge with any union data inside the UpdateTodoRequest, using the provided UpdateTodoRequest2
func (t *UpdateTodoRequest) MergeUpdateTodoRequest2(v UpdateTodoRequest2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateTodoRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.DueDate != nil {
		object["due_date"], err = json.Marshal(t.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'due_date': %w", err)
		}
	}

	if t.Status != nil {
		object["status"], err = json.Marshal(t.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if t.Title != nil {
		object["title"], err = json.Marshal(t.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *UpdateTodoRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["due_date"]; found {
		err = json.Unmarshal(raw, &t.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'due_date': %w", err)
		}
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &t.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List todos
	// (GET /api/v1/todos)
	ListTodos(w http.ResponseWriter, r *http.Request, params ListTodosParams)
	// Create a todo
	// (POST /api/v1/todos)
	CreateTodo(w http.ResponseWriter, r *http.Request)
	// Update a todo
	// (PATCH /api/v1/todos/{todo_id})
	UpdateTodo(w http.ResponseWriter, r *http.Request, todoId openapi_types.UUID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListTodos operation middleware
func (siw *ServerInterfaceWrapper) ListTodos(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTodosParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Required query parameter "pagesize" -------------

	if paramValue := r.URL.Query().Get("pagesize"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "pagesize"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "pagesize", r.URL.Query(), &params.Pagesize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagesize", Err: err})
		return
	}

	// ------------- Required query parameter "page" -------------

	if paramValue := r.URL.Query().Get("page"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "page"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTodos(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateTodo operation middleware
func (siw *ServerInterfaceWrapper) CreateTodo(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTodo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateTodo operation middleware
func (siw *ServerInterfaceWrapper) UpdateTodo(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "todo_id" -------------
	var todoId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "todo_id", r.PathValue("todo_id"), &todoId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "todo_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTodo(w, r, todoId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/api/v1/todos", wrapper.ListTodos)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/todos", wrapper.CreateTodo)
	m.HandleFunc("PATCH "+options.BaseURL+"/api/v1/todos/{todo_id}", wrapper.UpdateTodo)

	return m
}
